
<!-- HTML header for doxygen 1.8.8-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <!-- For Mobile Devices -->
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
        <meta name="generator" content="Doxygen 1.8.11"/>
        <script type="text/javascript" src="https://code.jquery.com/jquery-2.1.1.min.js"></script>
        <title>OpenGR: gr::MatchBase&lt; PointType, _TransformVisitor, OptExts &gt; Class Template Reference</title>
        <!--<link href="tabs.css" rel="stylesheet" type="text/css"/>-->
        <script type="text/javascript" src="dynsections.js"></script>
        <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
        <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSsymbols.js", "TeX/AMSmath.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
        <link href="tabs.css" rel="stylesheet" type="text/css"/>
        <link href="doxygen.css" rel="stylesheet" type="text/css" />
        <link href="customdoxygen.css" rel="stylesheet" type="text/css"/>
        <link href='https://fonts.googleapis.com/css?family=Roboto+Slab' rel='stylesheet' type='text/css'>
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.1/css/bootstrap.min.css">
        <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.1/js/bootstrap.min.js"></script>
        <script type="text/javascript" src="doxy-boot.js"></script>
    </head>
    <body>
        <nav class="navbar navbar-default" role="navigation">
            <div class="container">
                <div class="navbar-header">
                    <img alt="OpenGR-logo" src="logo_dox.png"/>
                    <div id="projectbrief">A 3D Global Registration Library</div>
                    <!-- <a class="navbar-brand">OpenGR V1.2.0(cba621e)</a> -->
                </div>
            </div>
        </nav>
        <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
            <div class="content" id="content">
                <div class="container">
                    <div class="row">
                        <div class="col-sm-12 panel " style="padding-bottom: 15px;">
                            <div style="margin-bottom: 15px;">
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="a00099.html">gr</a></li><li class="navelem"><a class="el" href="a00035.html">MatchBase</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#pro-static-attribs">Static Protected Attributes</a> &#124;
<a href="a00228.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">gr::MatchBase&lt; PointType, _TransformVisitor, OptExts &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Abstract class for registration algorithms.  
 <a href="a00035.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="a00088_source.html">matchBase.h</a>&gt;</code></p>
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Inheritance diagram for gr::MatchBase&lt; PointType, _TransformVisitor, OptExts &gt;:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
<div class="center"><div class="zoom"><iframe scrolling="no" frameborder="0" src="a00229.svg" width="100%" height="600"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
</div>
<div id="dynsection-1" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-1-trigger" src="closed.png" alt="+"/> Collaboration diagram for gr::MatchBase&lt; PointType, _TransformVisitor, OptExts &gt;:</div>
<div id="dynsection-1-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-1-content" class="dyncontent" style="display:none;">
<div class="center"><div class="zoom"><iframe scrolling="no" frameborder="0" src="a00230.svg" width="100%" height="600"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00039.html">Options</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00047.html">PosMutablePoint</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenience class used to wrap (any) PointType to allow mutation of position of point samples for internal computations.  <a href="a00047.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ad5c223f7812a1b113925762157ab4e52"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00035.html#ad5c223f7812a1b113925762157ab4e52">LogLevel</a> = <a class="el" href="a00101.html#ad36376e2e9f9c71561dca43867be64d4">Utils::LogLevel</a></td></tr>
<tr class="separator:ad5c223f7812a1b113925762157ab4e52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43fdb4a1feaf27e277158c092320edbc"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00035.html#a43fdb4a1feaf27e277158c092320edbc">MatrixType</a> = Eigen::Matrix&lt; <a class="el" href="a00035.html#ac9819a663e64c3278aea569a8f03707a">Scalar</a>, 4, 4 &gt;</td></tr>
<tr class="separator:a43fdb4a1feaf27e277158c092320edbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb4bc9c6d059ff6bcf03d8d7c991ef20"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00035.html#abb4bc9c6d059ff6bcf03d8d7c991ef20">OptionsType</a> = <a class="el" href="a00019.html">gr::Utils::CRTP</a>&lt; OptExts..., <a class="el" href="a00039.html">Options</a> &gt;</td></tr>
<tr class="separator:abb4bc9c6d059ff6bcf03d8d7c991ef20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9819a663e64c3278aea569a8f03707a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00035.html#ac9819a663e64c3278aea569a8f03707a">Scalar</a> = typename PointType::Scalar</td></tr>
<tr class="separator:ac9819a663e64c3278aea569a8f03707a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2967ceea275eff9eaf1e7b6afad3fee"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00035.html#ae2967ceea275eff9eaf1e7b6afad3fee">TransformVisitor</a> = _TransformVisitor</td></tr>
<tr class="separator:ae2967ceea275eff9eaf1e7b6afad3fee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0f5e12a230455077cbe77d5b14c0f79"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00035.html#af0f5e12a230455077cbe77d5b14c0f79">VectorType</a> = typename PointType::VectorType</td></tr>
<tr class="separator:af0f5e12a230455077cbe77d5b14c0f79"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a2628f0aa55be7241228942000397efb1"><td class="memTemplParams" colspan="2">template&lt;typename InputRange1 , typename InputRange2 , template&lt; typename &gt; typename Sampler&gt; </td></tr>
<tr class="memitem:a2628f0aa55be7241228942000397efb1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00035.html#ac9819a663e64c3278aea569a8f03707a">Scalar</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00035.html#a2628f0aa55be7241228942000397efb1">ComputeTransformation</a> (const InputRange1 &amp;P, const InputRange2 &amp;Q, Eigen::Ref&lt; <a class="el" href="a00035.html#a43fdb4a1feaf27e277158c092320edbc">MatrixType</a> &gt; transformation, const Sampler&lt; PointType &gt; &amp;sampler, <a class="el" href="a00035.html#ae2967ceea275eff9eaf1e7b6afad3fee">TransformVisitor</a> &amp;v)</td></tr>
<tr class="memdesc:a2628f0aa55be7241228942000397efb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes an approximation of the best LCP (directional) from Q to P and the rigid transformation that realizes it. The input sets may or may not contain normal information for any point.  <a href="#a2628f0aa55be7241228942000397efb1">More...</a><br /></td></tr>
<tr class="separator:a2628f0aa55be7241228942000397efb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adabb2c063c5dd1de2e6dc4a95ff8c3f3"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="a00047.html">PosMutablePoint</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00035.html#adabb2c063c5dd1de2e6dc4a95ff8c3f3">getFirstSampled</a> () const </td></tr>
<tr class="memdesc:adabb2c063c5dd1de2e6dc4a95ff8c3f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read access to the sampled clouds used for the registration.  <a href="#adabb2c063c5dd1de2e6dc4a95ff8c3f3">More...</a><br /></td></tr>
<tr class="separator:adabb2c063c5dd1de2e6dc4a95ff8c3f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa386f90d32f2006c62017ccabfb51135"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="a00047.html">PosMutablePoint</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00035.html#aa386f90d32f2006c62017ccabfb51135">getSecondSampled</a> () const </td></tr>
<tr class="memdesc:aa386f90d32f2006c62017ccabfb51135"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read access to the sampled clouds used for the registration.  <a href="#aa386f90d32f2006c62017ccabfb51135">More...</a><br /></td></tr>
<tr class="separator:aa386f90d32f2006c62017ccabfb51135"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ad8c6f0f29d348025802ef51257e953"><td class="memItemLeft" align="right" valign="top">EIGEN_MAKE_ALIGNED_OPERATOR_NEW&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00035.html#a6ad8c6f0f29d348025802ef51257e953">MatchBase</a> (const <a class="el" href="a00035.html#abb4bc9c6d059ff6bcf03d8d7c991ef20">OptionsType</a> &amp;options, const <a class="el" href="a00032.html">Utils::Logger</a> &amp;logger)</td></tr>
<tr class="separator:a6ad8c6f0f29d348025802ef51257e953"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a888273d0095afccf91b86b8094ccca59"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00035.html#a888273d0095afccf91b86b8094ccca59">~MatchBase</a> ()</td></tr>
<tr class="separator:a888273d0095afccf91b86b8094ccca59"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:ac971aca01f4e393b6d07c0e5e51fa645"><td class="memTemplParams" colspan="2">template&lt;typename Coordinates &gt; </td></tr>
<tr class="memitem:ac971aca01f4e393b6d07c0e5e51fa645"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00035.html#ac971aca01f4e393b6d07c0e5e51fa645">ComputeRigidTransformation</a> (const Coordinates &amp;ref, const Coordinates &amp;candidate, const Eigen::Matrix&lt; <a class="el" href="a00035.html#ac9819a663e64c3278aea569a8f03707a">Scalar</a>, 3, 1 &gt; &amp;centroid1, Eigen::Matrix&lt; <a class="el" href="a00035.html#ac9819a663e64c3278aea569a8f03707a">Scalar</a>, 3, 1 &gt; centroid2, Eigen::Ref&lt; <a class="el" href="a00035.html#a43fdb4a1feaf27e277158c092320edbc">MatrixType</a> &gt; transform, <a class="el" href="a00035.html#ac9819a663e64c3278aea569a8f03707a">Scalar</a> &amp;rms_, bool computeScale) const </td></tr>
<tr class="memdesc:ac971aca01f4e393b6d07c0e5e51fa645"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the best rigid transformation between three corresponding pairs. The transformation is characterized by rotation matrix, translation vector and a center about which we rotate. The set of pairs is potentially being updated by the best permutation of the second set. Returns the RMS of the fit. The method is being called with n points but it applies the fit for only 3 after the best permutation is selected in the second set (see bellow). This is done because the solution for planar points is much simpler. The method is the closed-form solution by Horn: people.csail.mit.edu/bkph/papers/Absolute_Orientation.pdf.  <a href="#ac971aca01f4e393b6d07c0e5e51fa645">More...</a><br /></td></tr>
<tr class="separator:ac971aca01f4e393b6d07c0e5e51fa645"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ddb5171b08fbd050bd9cf30d2ecf4be"><td class="memTemplParams" colspan="2">template&lt;typename InputRange1 , typename InputRange2 , template&lt; typename &gt; class Sampler&gt; </td></tr>
<tr class="memitem:a3ddb5171b08fbd050bd9cf30d2ecf4be"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00035.html#a3ddb5171b08fbd050bd9cf30d2ecf4be">init</a> (const InputRange1 &amp;P, const InputRange2 &amp;Q, const Sampler&lt; PointType &gt; &amp;sampler)</td></tr>
<tr class="memdesc:a3ddb5171b08fbd050bd9cf30d2ecf4be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the internal state of the Base class.  <a href="#a3ddb5171b08fbd050bd9cf30d2ecf4be">More...</a><br /></td></tr>
<tr class="separator:a3ddb5171b08fbd050bd9cf30d2ecf4be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e7cb9378539e3b0b3ed3a7572003f67"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00035.html#a4e7cb9378539e3b0b3ed3a7572003f67">Initialize</a> ()</td></tr>
<tr class="memdesc:a4e7cb9378539e3b0b3ed3a7572003f67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the data structures and needed values before the match computation. This method is called once the internal state of the Base class as been set.  <a href="#a4e7cb9378539e3b0b3ed3a7572003f67">More...</a><br /></td></tr>
<tr class="separator:a4e7cb9378539e3b0b3ed3a7572003f67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fe8bc2ec7d6af6481dae67161e47548"><td class="memTemplParams" colspan="2">template&lt;Utils::LogLevel level, typename... Args&gt; </td></tr>
<tr class="memitem:a5fe8bc2ec7d6af6481dae67161e47548"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00035.html#a5fe8bc2ec7d6af6481dae67161e47548">Log</a> (Args...args) const </td></tr>
<tr class="separator:a5fe8bc2ec7d6af6481dae67161e47548"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a312e46010aeef5797bd52c8d646acd47"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00035.html#ac9819a663e64c3278aea569a8f03707a">Scalar</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00035.html#a312e46010aeef5797bd52c8d646acd47">MeanDistance</a> () const </td></tr>
<tr class="memdesc:a312e46010aeef5797bd52c8d646acd47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the mean distance between points in Q and their nearest neighbor. We need this for normalization of the user delta (See the paper) to the "scale" of the set.  <a href="#a312e46010aeef5797bd52c8d646acd47">More...</a><br /></td></tr>
<tr class="separator:a312e46010aeef5797bd52c8d646acd47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f98e405170f96f2e9d72090aa4032ac"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00035.html#a1f98e405170f96f2e9d72090aa4032ac">SelectRandomTriangle</a> (<a class="el" href="a00035.html#ac9819a663e64c3278aea569a8f03707a">Scalar</a> max_base_diameter, <a class="el" href="a00114.html">int</a> &amp;base1, <a class="el" href="a00114.html">int</a> &amp;base2, <a class="el" href="a00114.html">int</a> &amp;base3)</td></tr>
<tr class="memdesc:a1f98e405170f96f2e9d72090aa4032ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Selects a random triangle in the set P (then we add another point to keep the base as planar as possible). We apply a simple heuristic that works in most practical cases. The idea is to accept maximum distance, computed by the estimated overlap, multiplied by the diameter of P, and try to have a triangle with all three edges close to this distance. Wide triangles helps to make the transformation robust while too large triangles makes the probability of having all points in the inliers small so we try to trade-off.  <a href="#a1f98e405170f96f2e9d72090aa4032ac">More...</a><br /></td></tr>
<tr class="separator:a1f98e405170f96f2e9d72090aa4032ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a859947d7745049c4122fbffe0b70b48d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00035.html#af0f5e12a230455077cbe77d5b14c0f79">VectorType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00035.html#a859947d7745049c4122fbffe0b70b48d">centroid_P_</a> {VectorType::Zero()}</td></tr>
<tr class="memdesc:a859947d7745049c4122fbffe0b70b48d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The centroid of P.  <a href="#a859947d7745049c4122fbffe0b70b48d">More...</a><br /></td></tr>
<tr class="separator:a859947d7745049c4122fbffe0b70b48d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bd7c6c378b9b5ac49781761237989e9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00035.html#af0f5e12a230455077cbe77d5b14c0f79">VectorType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00035.html#a2bd7c6c378b9b5ac49781761237989e9">centroid_Q_</a> {VectorType::Zero()}</td></tr>
<tr class="memdesc:a2bd7c6c378b9b5ac49781761237989e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">The centroid of Q.  <a href="#a2bd7c6c378b9b5ac49781761237989e9">More...</a><br /></td></tr>
<tr class="separator:a2bd7c6c378b9b5ac49781761237989e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6df752b0da4ad1c33dca34e4988a3624"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00031.html">KdTree</a>&lt; <a class="el" href="a00035.html#ac9819a663e64c3278aea569a8f03707a">Scalar</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00035.html#a6df752b0da4ad1c33dca34e4988a3624">kd_tree_</a></td></tr>
<tr class="memdesc:a6df752b0da4ad1c33dca34e4988a3624"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="a00031.html" title="3D Kdtree with reentrant queries ">KdTree</a> used to compute the LCP.  <a href="#a6df752b0da4ad1c33dca34e4988a3624">More...</a><br /></td></tr>
<tr class="separator:a6df752b0da4ad1c33dca34e4988a3624"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ca92996f0ba74a7de681510fb9f7fbb"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="a00032.html">Utils::Logger</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00035.html#a9ca92996f0ba74a7de681510fb9f7fbb">logger_</a></td></tr>
<tr class="separator:a9ca92996f0ba74a7de681510fb9f7fbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef30acc47f9b879a290406c1dfd8a5aa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00035.html#abb4bc9c6d059ff6bcf03d8d7c991ef20">OptionsType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00035.html#aef30acc47f9b879a290406c1dfd8a5aa">options_</a></td></tr>
<tr class="separator:aef30acc47f9b879a290406c1dfd8a5aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad39e758711261334dfbc74782734f951"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00035.html#ac9819a663e64c3278aea569a8f03707a">Scalar</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00035.html#ad39e758711261334dfbc74782734f951">P_diameter_</a> {<a class="el" href="a00035.html#ac9819a663e64c3278aea569a8f03707a">Scalar</a>( 0 )}</td></tr>
<tr class="memdesc:ad39e758711261334dfbc74782734f951"><td class="mdescLeft">&#160;</td><td class="mdescRight">The diameter of P.  <a href="#ad39e758711261334dfbc74782734f951">More...</a><br /></td></tr>
<tr class="separator:ad39e758711261334dfbc74782734f951"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae917808aaa69a2c097f376760f0990f0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00035.html#ac9819a663e64c3278aea569a8f03707a">Scalar</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00035.html#ae917808aaa69a2c097f376760f0990f0">P_mean_distance_</a> {<a class="el" href="a00035.html#ac9819a663e64c3278aea569a8f03707a">Scalar</a>( 0 )}</td></tr>
<tr class="memdesc:ae917808aaa69a2c097f376760f0990f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mean distance between points and their nearest neighbor in the set P. Used to normalize the "delta" which is given in terms of this distance.  <a href="#ae917808aaa69a2c097f376760f0990f0">More...</a><br /></td></tr>
<tr class="separator:ae917808aaa69a2c097f376760f0990f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35899b54900318fd5dcc5760c09b6d6f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00035.html#af0f5e12a230455077cbe77d5b14c0f79">VectorType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00035.html#a35899b54900318fd5dcc5760c09b6d6f">qcentroid1_</a> {VectorType::Zero()}</td></tr>
<tr class="separator:a35899b54900318fd5dcc5760c09b6d6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9bd0ae6e991c9df252345b3e93327fc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00035.html#af0f5e12a230455077cbe77d5b14c0f79">VectorType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00035.html#ae9bd0ae6e991c9df252345b3e93327fc">qcentroid2_</a> {VectorType::Zero()}</td></tr>
<tr class="separator:ae9bd0ae6e991c9df252345b3e93327fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4fc50ede06f4c504b708128865b7c2b"><td class="memItemLeft" align="right" valign="top">std::mt19937&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00035.html#ab4fc50ede06f4c504b708128865b7c2b">randomGenerator_</a></td></tr>
<tr class="separator:ab4fc50ede06f4c504b708128865b7c2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b373889b1e67d7fc9e6df33c657fdc1"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="a00047.html">PosMutablePoint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00035.html#a1b373889b1e67d7fc9e6df33c657fdc1">sampled_P_3D_</a></td></tr>
<tr class="memdesc:a1b373889b1e67d7fc9e6df33c657fdc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sampled P (3D coordinates).  <a href="#a1b373889b1e67d7fc9e6df33c657fdc1">More...</a><br /></td></tr>
<tr class="separator:a1b373889b1e67d7fc9e6df33c657fdc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9633749c30edae74dc4e5df3c99b2c0"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="a00047.html">PosMutablePoint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00035.html#ae9633749c30edae74dc4e5df3c99b2c0">sampled_Q_3D_</a></td></tr>
<tr class="memdesc:ae9633749c30edae74dc4e5df3c99b2c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sampled Q (3D coordinates).  <a href="#ae9633749c30edae74dc4e5df3c99b2c0">More...</a><br /></td></tr>
<tr class="separator:ae9633749c30edae74dc4e5df3c99b2c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7236be5c31766cccb4dae658bb4421a"><td class="memItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="a00035.html#ac9819a663e64c3278aea569a8f03707a">Scalar</a>, 4, 4 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00035.html#ae7236be5c31766cccb4dae658bb4421a">transform_</a> {Eigen::Matrix&lt;<a class="el" href="a00035.html#ac9819a663e64c3278aea569a8f03707a">Scalar</a>, 4, 4&gt;::Identity()}</td></tr>
<tr class="memdesc:ae7236be5c31766cccb4dae658bb4421a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The transformation matrix by wich we transform Q to P.  <a href="#ae7236be5c31766cccb4dae658bb4421a">More...</a><br /></td></tr>
<tr class="separator:ae7236be5c31766cccb4dae658bb4421a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-static-attribs"></a>
Static Protected Attributes</h2></td></tr>
<tr class="memitem:aa48a2f0a32780f1579c1f794ff458a9c"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="a00114.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00035.html#aa48a2f0a32780f1579c1f794ff458a9c">kNumberOfDiameterTrials</a> = 1000</td></tr>
<tr class="separator:aa48a2f0a32780f1579c1f794ff458a9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename PointType, typename _TransformVisitor = DummyTransformVisitor, template&lt; class, class &gt; class... OptExts&gt;<br />
class gr::MatchBase&lt; PointType, _TransformVisitor, OptExts &gt;</h3>

<p>Abstract class for registration algorithms. </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a class="anchor" id="ad5c223f7812a1b113925762157ab4e52"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointType, typename _TransformVisitor = DummyTransformVisitor, template&lt; class, class &gt; class... OptExts&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="a00035.html">gr::MatchBase</a>&lt; PointType, _TransformVisitor, OptExts &gt;::<a class="el" href="a00101.html#ad36376e2e9f9c71561dca43867be64d4">LogLevel</a> =  <a class="el" href="a00101.html#ad36376e2e9f9c71561dca43867be64d4">Utils::LogLevel</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a43fdb4a1feaf27e277158c092320edbc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointType, typename _TransformVisitor = DummyTransformVisitor, template&lt; class, class &gt; class... OptExts&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="a00035.html">gr::MatchBase</a>&lt; PointType, _TransformVisitor, OptExts &gt;::<a class="el" href="a00035.html#a43fdb4a1feaf27e277158c092320edbc">MatrixType</a> =  Eigen::Matrix&lt;<a class="el" href="a00035.html#ac9819a663e64c3278aea569a8f03707a">Scalar</a>, 4, 4&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="abb4bc9c6d059ff6bcf03d8d7c991ef20"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointType, typename _TransformVisitor = DummyTransformVisitor, template&lt; class, class &gt; class... OptExts&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="a00035.html">gr::MatchBase</a>&lt; PointType, _TransformVisitor, OptExts &gt;::<a class="el" href="a00035.html#abb4bc9c6d059ff6bcf03d8d7c991ef20">OptionsType</a> =  <a class="el" href="a00019.html">gr::Utils::CRTP</a> &lt; OptExts ... , <a class="el" href="a00039.html">Options</a> &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ac9819a663e64c3278aea569a8f03707a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointType, typename _TransformVisitor = DummyTransformVisitor, template&lt; class, class &gt; class... OptExts&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="a00035.html">gr::MatchBase</a>&lt; PointType, _TransformVisitor, OptExts &gt;::<a class="el" href="a00035.html#ac9819a663e64c3278aea569a8f03707a">Scalar</a> =  typename PointType::Scalar</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ae2967ceea275eff9eaf1e7b6afad3fee"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointType, typename _TransformVisitor = DummyTransformVisitor, template&lt; class, class &gt; class... OptExts&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="a00035.html">gr::MatchBase</a>&lt; PointType, _TransformVisitor, OptExts &gt;::<a class="el" href="a00035.html#ae2967ceea275eff9eaf1e7b6afad3fee">TransformVisitor</a> =  _TransformVisitor</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="af0f5e12a230455077cbe77d5b14c0f79"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointType, typename _TransformVisitor = DummyTransformVisitor, template&lt; class, class &gt; class... OptExts&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="a00035.html">gr::MatchBase</a>&lt; PointType, _TransformVisitor, OptExts &gt;::<a class="el" href="a00035.html#af0f5e12a230455077cbe77d5b14c0f79">VectorType</a> =  typename PointType::VectorType</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a6ad8c6f0f29d348025802ef51257e953"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointType, typename _TransformVisitor = DummyTransformVisitor, template&lt; class, class &gt; class... OptExts&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">EIGEN_MAKE_ALIGNED_OPERATOR_NEW <a class="el" href="a00035.html">gr::MatchBase</a>&lt; PointType, _TransformVisitor, OptExts &gt;::<a class="el" href="a00035.html">MatchBase</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00035.html#abb4bc9c6d059ff6bcf03d8d7c991ef20">OptionsType</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00032.html">Utils::Logger</a> &amp;&#160;</td>
          <td class="paramname"><em>logger</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a888273d0095afccf91b86b8094ccca59"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointType, typename _TransformVisitor = DummyTransformVisitor, template&lt; class, class &gt; class... OptExts&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="a00035.html">gr::MatchBase</a>&lt; PointType, _TransformVisitor, OptExts &gt;::~<a class="el" href="a00035.html">MatchBase</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="ac971aca01f4e393b6d07c0e5e51fa645"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointType, typename _TransformVisitor = DummyTransformVisitor, template&lt; class, class &gt; class... OptExts&gt; </div>
<div class="memtemplate">
template&lt;typename Coordinates &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="a00035.html">gr::MatchBase</a>&lt; PointType, _TransformVisitor, OptExts &gt;::ComputeRigidTransformation </td>
          <td>(</td>
          <td class="paramtype">const Coordinates &amp;&#160;</td>
          <td class="paramname"><em>ref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Coordinates &amp;&#160;</td>
          <td class="paramname"><em>candidate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; <a class="el" href="a00035.html#ac9819a663e64c3278aea569a8f03707a">Scalar</a>, 3, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>centroid1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Matrix&lt; <a class="el" href="a00035.html#ac9819a663e64c3278aea569a8f03707a">Scalar</a>, 3, 1 &gt;&#160;</td>
          <td class="paramname"><em>centroid2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Ref&lt; <a class="el" href="a00035.html#a43fdb4a1feaf27e277158c092320edbc">MatrixType</a> &gt;&#160;</td>
          <td class="paramname"><em>transform</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00035.html#ac9819a663e64c3278aea569a8f03707a">Scalar</a> &amp;&#160;</td>
          <td class="paramname"><em>rms_</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>computeScale</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the best rigid transformation between three corresponding pairs. The transformation is characterized by rotation matrix, translation vector and a center about which we rotate. The set of pairs is potentially being updated by the best permutation of the second set. Returns the RMS of the fit. The method is being called with n points but it applies the fit for only 3 after the best permutation is selected in the second set (see bellow). This is done because the solution for planar points is much simpler. The method is the closed-form solution by Horn: people.csail.mit.edu/bkph/papers/Absolute_Orientation.pdf. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Coordinates</td><td>Struct with operator[](int i) -&gt;i[0:2] </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2628f0aa55be7241228942000397efb1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointType, typename _TransformVisitor = DummyTransformVisitor, template&lt; class, class &gt; class... OptExts&gt; </div>
<div class="memtemplate">
template&lt;typename InputRange1 , typename InputRange2 , template&lt; typename &gt; typename Sampler&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00035.html#ac9819a663e64c3278aea569a8f03707a">Scalar</a> <a class="el" href="a00035.html">gr::MatchBase</a>&lt; PointType, _TransformVisitor, OptExts &gt;::ComputeTransformation </td>
          <td>(</td>
          <td class="paramtype">const InputRange1 &amp;&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InputRange2 &amp;&#160;</td>
          <td class="paramname"><em>Q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Ref&lt; <a class="el" href="a00035.html#a43fdb4a1feaf27e277158c092320edbc">MatrixType</a> &gt;&#160;</td>
          <td class="paramname"><em>transformation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Sampler&lt; PointType &gt; &amp;&#160;</td>
          <td class="paramname"><em>sampler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00035.html#ae2967ceea275eff9eaf1e7b6afad3fee">TransformVisitor</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes an approximation of the best LCP (directional) from Q to P and the rigid transformation that realizes it. The input sets may or may not contain normal information for any point. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">P</td><td>The first input set. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Q</td><td>The second input set. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">transformation</td><td>Rigid transformation matrix (4x4) that brings Q to the (approximate) optimal LCP. Initial value is considered as a guess </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the computed LCP measure as a fraction of the size of P ([0..1]). Computes an approximation of the best LCP (directional) from Q to P and the rigid transformation that realizes it. The input sets may or may not contain normal information for any point. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">P</td><td>The first input set. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Q</td><td>The second input set. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">transformation</td><td>Rigid transformation matrix (4x4) that brings Q to the (approximate) optimal LCP. Initial value is considered as a guess </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the computed LCP measure as a fraction of the size of P ([0..1]). </dd></dl>

</div>
</div>
<a class="anchor" id="adabb2c063c5dd1de2e6dc4a95ff8c3f3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointType, typename _TransformVisitor = DummyTransformVisitor, template&lt; class, class &gt; class... OptExts&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;<a class="el" href="a00047.html">PosMutablePoint</a>&gt;&amp; <a class="el" href="a00035.html">gr::MatchBase</a>&lt; PointType, _TransformVisitor, OptExts &gt;::getFirstSampled </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read access to the sampled clouds used for the registration. </p>

</div>
</div>
<a class="anchor" id="aa386f90d32f2006c62017ccabfb51135"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointType, typename _TransformVisitor = DummyTransformVisitor, template&lt; class, class &gt; class... OptExts&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;<a class="el" href="a00047.html">PosMutablePoint</a>&gt;&amp; <a class="el" href="a00035.html">gr::MatchBase</a>&lt; PointType, _TransformVisitor, OptExts &gt;::getSecondSampled </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read access to the sampled clouds used for the registration. </p>

</div>
</div>
<a class="anchor" id="a3ddb5171b08fbd050bd9cf30d2ecf4be"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointType, typename _TransformVisitor = DummyTransformVisitor, template&lt; class, class &gt; class... OptExts&gt; </div>
<div class="memtemplate">
template&lt;typename InputRange1 , typename InputRange2 , template&lt; typename &gt; class Sampler&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00035.html">gr::MatchBase</a>&lt; PointType, _TransformVisitor, OptExts &gt;::init </td>
          <td>(</td>
          <td class="paramtype">const InputRange1 &amp;&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InputRange2 &amp;&#160;</td>
          <td class="paramname"><em>Q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Sampler&lt; PointType &gt; &amp;&#160;</td>
          <td class="paramname"><em>sampler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes the internal state of the Base class. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">P</td><td>The first input set. </td></tr>
    <tr><td class="paramname">Q</td><td>The second input set. </td></tr>
    <tr><td class="paramname">sampler</td><td>The sampler used to sample the input sets. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4e7cb9378539e3b0b3ed3a7572003f67"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointType, typename _TransformVisitor = DummyTransformVisitor, template&lt; class, class &gt; class... OptExts&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="a00035.html">gr::MatchBase</a>&lt; PointType, _TransformVisitor, OptExts &gt;::Initialize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes the data structures and needed values before the match computation. This method is called once the internal state of the Base class as been set. </p>

<p>Reimplemented in <a class="el" href="a00034.html#a598cf856f9d70577cf7c0b367ce60f26">gr::Match4pcsBase&lt; _Functor, _PointType, _TransformVisitor, _PairFilteringFunctor, PairFilteringOptions &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a5fe8bc2ec7d6af6481dae67161e47548"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointType, typename _TransformVisitor = DummyTransformVisitor, template&lt; class, class &gt; class... OptExts&gt; </div>
<div class="memtemplate">
template&lt;Utils::LogLevel level, typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00035.html">gr::MatchBase</a>&lt; PointType, _TransformVisitor, OptExts &gt;::Log </td>
          <td>(</td>
          <td class="paramtype">Args...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a312e46010aeef5797bd52c8d646acd47"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointType, typename _TransformVisitor = DummyTransformVisitor, template&lt; class, class &gt; class... OptExts&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00035.html#ac9819a663e64c3278aea569a8f03707a">Scalar</a> <a class="el" href="a00035.html">gr::MatchBase</a>&lt; PointType, _TransformVisitor, OptExts &gt;::MeanDistance </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the mean distance between points in Q and their nearest neighbor. We need this for normalization of the user delta (See the paper) to the "scale" of the set. </p>

</div>
</div>
<a class="anchor" id="a1f98e405170f96f2e9d72090aa4032ac"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointType, typename _TransformVisitor = DummyTransformVisitor, template&lt; class, class &gt; class... OptExts&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="a00035.html">gr::MatchBase</a>&lt; PointType, _TransformVisitor, OptExts &gt;::SelectRandomTriangle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00035.html#ac9819a663e64c3278aea569a8f03707a">Scalar</a>&#160;</td>
          <td class="paramname"><em>max_base_diameter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00114.html">int</a> &amp;&#160;</td>
          <td class="paramname"><em>base1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00114.html">int</a> &amp;&#160;</td>
          <td class="paramname"><em>base2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00114.html">int</a> &amp;&#160;</td>
          <td class="paramname"><em>base3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Selects a random triangle in the set P (then we add another point to keep the base as planar as possible). We apply a simple heuristic that works in most practical cases. The idea is to accept maximum distance, computed by the estimated overlap, multiplied by the diameter of P, and try to have a triangle with all three edges close to this distance. Wide triangles helps to make the transformation robust while too large triangles makes the probability of having all points in the inliers small so we try to trade-off. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">max_base_diameter</td><td>Maximum size allowed between two points of the base </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="a859947d7745049c4122fbffe0b70b48d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointType, typename _TransformVisitor = DummyTransformVisitor, template&lt; class, class &gt; class... OptExts&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00035.html#af0f5e12a230455077cbe77d5b14c0f79">VectorType</a> <a class="el" href="a00035.html">gr::MatchBase</a>&lt; PointType, _TransformVisitor, OptExts &gt;::centroid_P_ {VectorType::Zero()}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The centroid of P. </p>

</div>
</div>
<a class="anchor" id="a2bd7c6c378b9b5ac49781761237989e9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointType, typename _TransformVisitor = DummyTransformVisitor, template&lt; class, class &gt; class... OptExts&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00035.html#af0f5e12a230455077cbe77d5b14c0f79">VectorType</a> <a class="el" href="a00035.html">gr::MatchBase</a>&lt; PointType, _TransformVisitor, OptExts &gt;::centroid_Q_ {VectorType::Zero()}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The centroid of Q. </p>

</div>
</div>
<a class="anchor" id="a6df752b0da4ad1c33dca34e4988a3624"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointType, typename _TransformVisitor = DummyTransformVisitor, template&lt; class, class &gt; class... OptExts&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00031.html">KdTree</a>&lt;<a class="el" href="a00035.html#ac9819a663e64c3278aea569a8f03707a">Scalar</a>&gt; <a class="el" href="a00035.html">gr::MatchBase</a>&lt; PointType, _TransformVisitor, OptExts &gt;::kd_tree_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="a00031.html" title="3D Kdtree with reentrant queries ">KdTree</a> used to compute the LCP. </p>

</div>
</div>
<a class="anchor" id="aa48a2f0a32780f1579c1f794ff458a9c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointType, typename _TransformVisitor = DummyTransformVisitor, template&lt; class, class &gt; class... OptExts&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="a00114.html">int</a> <a class="el" href="a00035.html">gr::MatchBase</a>&lt; PointType, _TransformVisitor, OptExts &gt;::kNumberOfDiameterTrials = 1000</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="todo"><dt><b><a class="el" href="a00001.html#_todo000004">Todo:</a></b></dt><dd>Rationnalize use and name of this variable </dd></dl>

</div>
</div>
<a class="anchor" id="a9ca92996f0ba74a7de681510fb9f7fbb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointType, typename _TransformVisitor = DummyTransformVisitor, template&lt; class, class &gt; class... OptExts&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="a00032.html">Utils::Logger</a>&amp; <a class="el" href="a00035.html">gr::MatchBase</a>&lt; PointType, _TransformVisitor, OptExts &gt;::logger_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aef30acc47f9b879a290406c1dfd8a5aa"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointType, typename _TransformVisitor = DummyTransformVisitor, template&lt; class, class &gt; class... OptExts&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00035.html#abb4bc9c6d059ff6bcf03d8d7c991ef20">OptionsType</a> <a class="el" href="a00035.html">gr::MatchBase</a>&lt; PointType, _TransformVisitor, OptExts &gt;::options_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ad39e758711261334dfbc74782734f951"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointType, typename _TransformVisitor = DummyTransformVisitor, template&lt; class, class &gt; class... OptExts&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00035.html#ac9819a663e64c3278aea569a8f03707a">Scalar</a> <a class="el" href="a00035.html">gr::MatchBase</a>&lt; PointType, _TransformVisitor, OptExts &gt;::P_diameter_ {<a class="el" href="a00035.html#ac9819a663e64c3278aea569a8f03707a">Scalar</a>( 0 )}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The diameter of P. </p>

</div>
</div>
<a class="anchor" id="ae917808aaa69a2c097f376760f0990f0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointType, typename _TransformVisitor = DummyTransformVisitor, template&lt; class, class &gt; class... OptExts&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00035.html#ac9819a663e64c3278aea569a8f03707a">Scalar</a> <a class="el" href="a00035.html">gr::MatchBase</a>&lt; PointType, _TransformVisitor, OptExts &gt;::P_mean_distance_ {<a class="el" href="a00035.html#ac9819a663e64c3278aea569a8f03707a">Scalar</a>( 0 )}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Mean distance between points and their nearest neighbor in the set P. Used to normalize the "delta" which is given in terms of this distance. </p>

</div>
</div>
<a class="anchor" id="a35899b54900318fd5dcc5760c09b6d6f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointType, typename _TransformVisitor = DummyTransformVisitor, template&lt; class, class &gt; class... OptExts&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00035.html#af0f5e12a230455077cbe77d5b14c0f79">VectorType</a> <a class="el" href="a00035.html">gr::MatchBase</a>&lt; PointType, _TransformVisitor, OptExts &gt;::qcentroid1_ {VectorType::Zero()}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ae9bd0ae6e991c9df252345b3e93327fc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointType, typename _TransformVisitor = DummyTransformVisitor, template&lt; class, class &gt; class... OptExts&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00035.html#af0f5e12a230455077cbe77d5b14c0f79">VectorType</a> <a class="el" href="a00035.html">gr::MatchBase</a>&lt; PointType, _TransformVisitor, OptExts &gt;::qcentroid2_ {VectorType::Zero()}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ab4fc50ede06f4c504b708128865b7c2b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointType, typename _TransformVisitor = DummyTransformVisitor, template&lt; class, class &gt; class... OptExts&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::mt19937 <a class="el" href="a00035.html">gr::MatchBase</a>&lt; PointType, _TransformVisitor, OptExts &gt;::randomGenerator_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a1b373889b1e67d7fc9e6df33c657fdc1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointType, typename _TransformVisitor = DummyTransformVisitor, template&lt; class, class &gt; class... OptExts&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="a00047.html">PosMutablePoint</a>&gt; <a class="el" href="a00035.html">gr::MatchBase</a>&lt; PointType, _TransformVisitor, OptExts &gt;::sampled_P_3D_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sampled P (3D coordinates). </p>

</div>
</div>
<a class="anchor" id="ae9633749c30edae74dc4e5df3c99b2c0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointType, typename _TransformVisitor = DummyTransformVisitor, template&lt; class, class &gt; class... OptExts&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="a00047.html">PosMutablePoint</a>&gt; <a class="el" href="a00035.html">gr::MatchBase</a>&lt; PointType, _TransformVisitor, OptExts &gt;::sampled_Q_3D_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sampled Q (3D coordinates). </p>

</div>
</div>
<a class="anchor" id="ae7236be5c31766cccb4dae658bb4421a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointType, typename _TransformVisitor = DummyTransformVisitor, template&lt; class, class &gt; class... OptExts&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;<a class="el" href="a00035.html#ac9819a663e64c3278aea569a8f03707a">Scalar</a>, 4, 4&gt; <a class="el" href="a00035.html">gr::MatchBase</a>&lt; PointType, _TransformVisitor, OptExts &gt;::transform_ {Eigen::Matrix&lt;<a class="el" href="a00035.html#ac9819a663e64c3278aea569a8f03707a">Scalar</a>, 4, 4&gt;::Identity()}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The transformation matrix by wich we transform Q to P. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/home/travis/build/STORM-IRIT/OpenGR/src/gr/algorithms/<a class="el" href="a00088_source.html">matchBase.h</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.8-->
<!-- start footer part -->
</div>
</div>
</div>
</div>
</div>
<hr class="footer"/><address class="footer"><small>
Generated on Tue Aug 11 2020 09:56:54 for OpenGR by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
