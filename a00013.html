
<!-- HTML header for doxygen 1.8.8-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <!-- For Mobile Devices -->
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
        <meta name="generator" content="Doxygen 1.8.11"/>
        <script type="text/javascript" src="https://code.jquery.com/jquery-2.1.1.min.js"></script>
        <title>OpenGR: Using Your Point Type</title>
        <!--<link href="tabs.css" rel="stylesheet" type="text/css"/>-->
        <script type="text/javascript" src="dynsections.js"></script>
        <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
        <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSsymbols.js", "TeX/AMSmath.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
        <link href="tabs.css" rel="stylesheet" type="text/css"/>
        <link href="doxygen.css" rel="stylesheet" type="text/css" />
        <link href="customdoxygen.css" rel="stylesheet" type="text/css"/>
        <link href='https://fonts.googleapis.com/css?family=Roboto+Slab' rel='stylesheet' type='text/css'>
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.1/css/bootstrap.min.css">
        <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.1/js/bootstrap.min.js"></script>
        <script type="text/javascript" src="doxy-boot.js"></script>
    </head>
    <body>
        <nav class="navbar navbar-default" role="navigation">
            <div class="container">
                <div class="navbar-header">
                    <img alt="OpenGR-logo" src="logo_dox.png"/>
                    <div id="projectbrief">A 3D Global Registration Library</div>
                    <!-- <a class="navbar-brand">OpenGR V1.2.0(cba621e)</a> -->
                </div>
            </div>
        </nav>
        <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
            <div class="content" id="content">
                <div class="container">
                    <div class="row">
                        <div class="col-sm-12 panel " style="padding-bottom: 15px;">
                            <div style="margin-bottom: 15px;">
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="index.html">User documentation</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Using Your Point Type </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>OpenGR provides <a class="el" href="a00046.html">gr::PointConcept</a>, which it relies on while operating with the point samples internally. While <a class="el" href="a00046.html">gr::PointConcept</a> yields the least requirements for any point type that could be used as input to OpenGR, additional features could be introduced to be used as you extend the library, e.g., to employ different point filters while comparing two point instances considering additional features.</p>
<p>When an existing external point type is going to be used as input to OpenGR, <a class="el" href="a00046.html">gr::PointConcept</a> can be implemented to behave as a wrapper (i.e. adapter) for the external point type. In this case, two types will be in question: the external point type whose instances are available to be passed to OpenGR, and the point type whose implementation is available to work as an adapter of the external point type to provide required interface to OpenGR. For registration, at the sampling stage, points are reinstantiated of the point adapter type which is given as template point type parameter. The requirement with <a class="el" href="a00046.html">gr::PointConcept</a> for a constructor, which takes an instance of the external point type as input, is handy when the given point adapter type is not the same as the type of the input point instances. In other words, this constructor is used to reinstantiate the point sample with the given point adapter type at the sampling stage, so that, the provided interface could be used internally through the adapter.</p>
<p>In the other case, if the type of the input point instances provides the required interface, the type of input point instances could be passed as the template type parameter. This way, the required constructor turns out to be the copy constructor of the point type. Therefore, the sample points are copied using the copy constructor of the point type at the sampling stage. Although this allows to avoid implementing an additional adapter type, one could consider using an mapper adapter if the copy constructor causes memory duplicates of the underlying point sample data.</p>
<p>Internally, OpenGR uses Eigen for computation, vector representation and vectorization. Therefore, it expects <a class="el" href="a00046.html#a219bf6914063c5325c7a6f2c6b12f3cb" title="Defines type used to encode vector values. ">gr::PointConcept::VectorType</a> to be compatible with Eigen::DenseBase, as apparent in <a class="el" href="a00046.html">gr::PointConcept</a>. To use existing point types without requiring any memory duplication while complying with this requirement, Eigen::Map could be used to map data of existing point types as an Eigen matrix or vector.</p>
<p>For convenience, OpenGR provides an implementation for <a class="el" href="a00046.html">gr::PointConcept</a>: <a class="el" href="a00045.html" title="The basic 3D point structure. A point potentially contains also directional information and color...">gr::Point3D</a>. IO methods for <a class="el" href="a00045.html" title="The basic 3D point structure. A point potentially contains also directional information and color...">gr::Point3D</a> is also provided with the library to use the library on supported point cloud files without needing to implement the point concept and the IO methods.</p>
<p>Following examples show two simple point type classes demonstrating possible point types external to OpenGR, and the adapters for those point types that allow OpenGR to work on the instances of them without needing any duplication of data while complying with the required interface of the point type concept: <a class="el" href="a00046.html">gr::PointConcept</a>.</p>
<h3>Example: Using an external point type: <code>extlib1::PointType1</code></h3>
<p><a class="anchor" id="extlib1-pointtype"></a></p><div class="fragment"><div class="line"><span class="keyword">namespace </span>extlib1</div><div class="line">{</div><div class="line">  <span class="keyword">struct </span>PointType1 {</div><div class="line">    <span class="keywordtype">float</span> pos[3];   <span class="comment">// position</span></div><div class="line">    <span class="keywordtype">float</span> n[3];     <span class="comment">// normal</span></div><div class="line">    <span class="keywordtype">float</span> color[3]; <span class="comment">// color</span></div><div class="line">  };</div><div class="line">}</div></div><!-- fragment --><p> Assuming that we have an external point type <code>extlib1::PointType1</code> as defined above, which is used by some library ExtLib1, it is sufficient to implement the below point adapter <code>extlib1::PointAdapter</code>, and pass the type of the point adapter as the point type while instantiating any template class or method of OpenGR. OpenGR will wrap your point type with the adapter, and use the interface provided by the adapter for its computations.</p>
<p><a class="anchor" id="extlib1-pointadapter"></a></p><div class="fragment"><div class="line"><span class="keyword">namespace </span>extlib1</div><div class="line">{</div><div class="line"></div><div class="line"><span class="keyword">struct </span>PointAdapter {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    <span class="keyword">enum</span> {Dim = 3};</div><div class="line">    <span class="keyword">typedef</span> <span class="keywordtype">float</span> <a class="code" href="a00113.html">Scalar</a>;</div><div class="line">    <span class="keyword">typedef</span> Eigen::Matrix&lt;Scalar, Dim, 1&gt; <a class="code" href="a00153.html">VectorType</a>;</div><div class="line"></div><div class="line">  <span class="keyword">private</span>:</div><div class="line">    Eigen::Map&lt;const VectorType&gt; m_pos, m_normal, m_color;</div><div class="line"></div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    <span class="keyword">inline</span> PointAdapter(<span class="keyword">const</span> extlib1::PointType1&amp; p)</div><div class="line">      : m_pos   (Eigen::Map&lt;const VectorType &gt;( p.pos )),</div><div class="line">        m_normal(Eigen::Map&lt;const VectorType &gt;( p.n )),</div><div class="line">        m_color (Eigen::Map&lt;const VectorType &gt;( p.color ))</div><div class="line">    { }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">inline</span> <span class="keyword">const</span> Eigen::Map&lt; const VectorType &gt;&amp; pos()<span class="keyword">    const </span>{ <span class="keywordflow">return</span> m_pos; }</div><div class="line">    <span class="keyword">inline</span> <span class="keyword">const</span> Eigen::Map&lt; const VectorType &gt;&amp; normal()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> m_normal; }</div><div class="line">    <span class="keyword">inline</span> <span class="keyword">const</span> Eigen::Map&lt; const VectorType &gt;&amp; color()<span class="keyword">  const </span>{ <span class="keywordflow">return</span> m_color; }</div><div class="line">    <span class="keyword">inline</span> <span class="keyword">const</span> Eigen::Map&lt; const VectorType &gt;&amp; rgb()<span class="keyword">    const </span>{ <span class="keywordflow">return</span> m_color; }</div><div class="line"></div><div class="line">};</div><div class="line"></div><div class="line">}</div></div><!-- fragment --><p> Note that some members of the point adapter <code>extlib1::PointAdapter</code> is not required by default, but could be useful when used with point filters that make use of those members. For example, the methods <code>normal()</code> and <code>color()</code> are handful for point filters that use normal and color attributes of points while comparing two points, such as <a class="el" href="a00015.html" title="Functor used in n-pcs algorithm to filters pairs of points according to the exploration basis...">gr::AdaptivePointFilter</a>.</p>
<p>The <code>ExtPointBinding</code> demo demonstrates the external point binding through point adapters by using the above external point type <code>extlib1::PointType1</code> together with another external point type <code>extlib2::PointType2</code>.</p>
<h4>Registration using Super4PCS</h4>
<p>In this section, registration of points of an example external point type is briefly discussed by referring to the point adapter shown. This example is extracted from the demo <code>ExtPointBinding</code>, for which complete code could be found.</p>
<p>Let's say we have two <code>std::vector</code> instances that contain two point clouds with point type <a class="el" href="a00013.html#extlib1-pointtype">extlib1::PointType1</a>, which we would like to compute a registration transform using Super4PCS algorithm:</p>
<div class="fragment"><div class="line">      std::vector&lt;extlib1::PointType1&gt; set1_point1 = getExtlib1Points(set1);</div><div class="line">      std::vector&lt;extlib1::PointType1&gt; set2_point1 = getExtlib1Points(set2);</div></div><!-- fragment --><p> In such case, we need to use <a class="el" href="a00013.html#extlib1-pointadapter">extlib1::PointAdapter</a> as our point type to allow OpenGR retrive the required attributes of our points of type <a class="el" href="a00013.html#extlib1-pointtype">extlib1::PointType1</a> by wrapping them with <a class="el" href="a00013.html#extlib1-pointadapter">extlib1::PointAdapter</a> on-the-fly. Therefore, the type of the adapter is used to instantiate the matcher type: </p><div class="fragment"><div class="line">      <span class="keyword">using</span> PointAdapter = extlib1::PointAdapter;</div><div class="line">      <span class="keyword">using</span> MatcherType = <a class="code" href="a00034.html">gr::Match4pcsBase</a>&lt;<a class="code" href="a00025.html">gr::FunctorSuper4PCS</a>,</div><div class="line">                                            PointAdapter, <span class="comment">// here is the adapter!</span></div><div class="line">                                            TrVisitorType,</div><div class="line">                                            <a class="code" href="a00015.html">gr::AdaptivePointFilter</a>,</div><div class="line">                                            <a class="code" href="a00040.html">gr::AdaptivePointFilter::Options</a>&gt;;</div></div><!-- fragment --><p> Also, the sampler type is instantiated using the point adapter type as sampler needs to retrieve attributes of the point as well: </p><div class="fragment"><div class="line">      UniformDistSampler&lt;PointAdapter&gt; sampler;</div></div><!-- fragment --><p> And, the rest for the registration transformation computation is as regular, instantiating the matcher and computing the registration transformation. Notice that the instances of the external point type are directly passed to the matcher, without requiring to make any type conversions: </p><div class="fragment"><div class="line">      <span class="comment">// Create a matcher instance</span></div><div class="line">      MatcherType matcher (options, logger);</div><div class="line">      <span class="comment">// Compute transformation: put transformation to mat, return registration score</span></div><div class="line">      <a class="code" href="a00113.html">Scalar</a> score = matcher.ComputeTransformation(set1_point1, set2_point1, mat, sampler, visitor);</div></div><!-- fragment --> <h3>Example: Using another external point type: <code>extlib2::PointType2</code></h3>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>extlib2</div><div class="line">{</div><div class="line">  <span class="keyword">struct </span>PointType2 {</div><div class="line">    <span class="keywordtype">float</span>* posBuffer;   <span class="comment">// position buffer</span></div><div class="line">    <span class="keywordtype">float</span>* nBuffer;     <span class="comment">// normal buffer</span></div><div class="line">    <span class="keywordtype">float</span>* colorBuffer; <span class="comment">// color buffer</span></div><div class="line">    <span class="keywordtype">int</span> id;             <span class="comment">// id (or index)</span></div><div class="line">  };</div><div class="line">}</div></div><!-- fragment --><p> Here, a different external point type, <code>extlib2::PointType2</code>, is shown, for which the point binding to OpenGR could be done using the below adapter type, <code>extlib2::PointAdapter</code>, in an efficient manner thanks to Eigen maps.</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>extlib2</div><div class="line">{</div><div class="line"></div><div class="line"><span class="keyword">struct </span>PointAdapter {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    <span class="keyword">enum</span> {Dim = 3};</div><div class="line">    <span class="keyword">typedef</span> <span class="keywordtype">float</span> <a class="code" href="a00113.html">Scalar</a>;</div><div class="line">    <span class="keyword">typedef</span> Eigen::Matrix&lt;Scalar, Dim, 1&gt; <a class="code" href="a00153.html">VectorType</a>;</div><div class="line"></div><div class="line">  <span class="keyword">private</span>:</div><div class="line">    Eigen::Map&lt; const VectorType &gt; m_pos, m_normal, m_color;</div><div class="line"></div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    <span class="keyword">inline</span> PointAdapter(<span class="keyword">const</span> extlib2::PointType2&amp; p)</div><div class="line">      : m_pos   (Eigen::Map&lt; const VectorType &gt;( p.posBuffer + Dim*p.id )),</div><div class="line">        m_normal(Eigen::Map&lt; const VectorType &gt;( p.nBuffer + Dim*p.id )),</div><div class="line">        m_color (Eigen::Map&lt; const VectorType &gt;( p.colorBuffer + Dim*p.id ))</div><div class="line">    { }</div><div class="line"></div><div class="line">    <span class="keyword">inline</span> <span class="keyword">const</span> Eigen::Map&lt; const VectorType &gt;&amp; pos()<span class="keyword">    const </span>{ <span class="keywordflow">return</span> m_pos; }</div><div class="line">    <span class="keyword">inline</span> <span class="keyword">const</span> Eigen::Map&lt; const VectorType &gt;&amp; normal()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> m_normal; }</div><div class="line">    <span class="keyword">inline</span> <span class="keyword">const</span> Eigen::Map&lt; const VectorType &gt;&amp; color()<span class="keyword">  const </span>{ <span class="keywordflow">return</span> m_color; }</div><div class="line">    <span class="keyword">inline</span> <span class="keyword">const</span> Eigen::Map&lt; const VectorType &gt;&amp; rgb()<span class="keyword">  const </span>{ <span class="keywordflow">return</span> m_color; }</div><div class="line"></div><div class="line">};</div><div class="line"></div><div class="line">}</div></div><!-- fragment --><p> For any external point type, when a proper point adapter is defined, which could be done with little effort in an efficient manner for most cases, OpenGR could be utilized as shown. </p>
</div></div><!-- contents -->
<!-- HTML footer for doxygen 1.8.8-->
<!-- start footer part -->
</div>
</div>
</div>
</div>
</div>
<hr class="footer"/><address class="footer"><small>
Generated on Tue Aug 11 2020 09:56:54 for OpenGR by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
